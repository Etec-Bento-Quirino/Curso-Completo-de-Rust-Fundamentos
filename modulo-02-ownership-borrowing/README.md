# M√≥dulo 2: Ownership e Borrowing

## üéØ Objetivos de Aprendizagem

Ao final deste m√≥dulo, voc√™ ser√° capaz de:

- ‚úÖ Compreender o sistema de ownership do Rust
- ‚úÖ Trabalhar com refer√™ncias e borrowing
- ‚úÖ Entender o conceito de lifetimes
- ‚úÖ Usar slices eficientemente
- ‚úÖ Evitar erros comuns de ownership
- ‚úÖ Aplicar as regras de ownership na pr√°tica

## üìã **Pr√©-requisitos**

### **Obrigat√≥rios**
- ‚úÖ **Conhecimento b√°sico de programa√ß√£o** - Vari√°veis, fun√ß√µes, estruturas de controle
- ‚úÖ **Rust (vers√£o 1.70 ou superior)** - [Instalar Rust](https://rustup.rs/)
- ‚úÖ **Cargo (gerenciador de pacotes)** - Instalado automaticamente com Rust
- ‚úÖ **Editor de c√≥digo** - [VS Code com rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) recomendado
- ‚úÖ **Git** - Para controle de vers√£o
- ‚úÖ **Conclus√£o do M√≥dulo 1** - [Fundamentos da Linguagem Rust](../modulo-01-fundamentos-rust/README.md)

### **Recomendados**
- ‚úÖ **Familiaridade com linha de comando** - Terminal/CMD b√°sico
- ‚úÖ **Conceitos b√°sicos de programa√ß√£o funcional** - Fun√ß√µes, imutabilidade
- ‚úÖ **Experi√™ncia com outras linguagens** - C/C++, Python, JavaScript, etc.
- ‚úÖ **Conceitos de sistemas operacionais** - Mem√≥ria, processos, threads

### **Recursos de Prepara√ß√£o**
- [**Rustlings**](https://github.com/rust-lang/rustlings) - Exerc√≠cios interativos para iniciantes
- [**The Rust Book**](https://doc.rust-lang.org/book/) - Documenta√ß√£o oficial completa
- [**Rust by Example**](https://doc.rust-lang.org/rust-by-example/) - Exemplos pr√°ticos
- [**Rust Playground**](https://play.rust-lang.org/) - Ambiente online para experimentar

## üìö **Recursos de Aprendizado**

### **Documenta√ß√£o Oficial**
- [**The Rust Book - Understanding Ownership**](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
- [**Rust by Example - Ownership**](https://doc.rust-lang.org/rust-by-example/scope/move.html)
- [**Rustlings - Ownership**](https://github.com/rust-lang/rustlings) - Exerc√≠cios interativos
- [**Rust Reference - Ownership**](https://doc.rust-lang.org/reference/ownership.html)

### **Comunidades e F√≥runs**
- [**Reddit r/rust**](https://reddit.com/r/rust) - Comunidade ativa
- [**Rust Users Forum**](https://users.rust-lang.org/) - F√≥rum oficial
- [**Stack Overflow**](https://stackoverflow.com/questions/tagged/rust) - Perguntas e respostas
- [**Rust Discord**](https://discord.gg/rust-lang) - Chat em tempo real

## üìñ **√çndice do M√≥dulo**

- [**Objetivos de Aprendizagem**](#-objetivos-de-aprendizagem)
- [**Pr√©-requisitos**](#-pr√©-requisitos)
- [**Recursos de Aprendizado**](#-recursos-de-aprendizado)
- [**Conte√∫do Te√≥rico**](#-conte√∫do-te√≥rico)
- [**Exemplos Pr√°ticos**](#-exemplos-pr√°ticos)
- [**Tutorial Pr√°tico**](#-tutorial-pr√°tico-gerenciador-de-strings)
- [**Atividades Pr√°ticas**](#-atividades-pr√°ticas)
- [**Exerc√≠cios de Fixa√ß√£o**](#-exerc√≠cios-de-fixa√ß√£o)
- [**Pr√≥ximos Passos**](#-pr√≥ximos-passos)
- [**Navega√ß√£o**](#-navega√ß√£o)

## üìö Conte√∫do Te√≥rico

### 2.1 O Sistema de Ownership

O ownership √© o recurso mais exclusivo do Rust que permite seguran√ßa de mem√≥ria sem garbage collector.

```mermaid
graph TD
    A[Valor Criado] --> B[Ownership Transferido]
    B --> C[Valor Usado]
    C --> D[Valor Liberado Automaticamente]
    
    E[Regra 1: Um valor tem apenas um owner] --> F[Regra 2: Apenas um owner por vez]
    F --> G[Regra 3: Owner sai de escopo = valor liberado]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#e8f5e8
    style E fill:#ffebee
    style F fill:#e3f2fd
    style G fill:#f1f8e9
```

**As Tr√™s Regras do Ownership:**

1. **Cada valor em Rust tem um owner**
2. **Apenas um owner por vez**
3. **Quando o owner sai de escopo, o valor √© liberado**

### 2.2 Stack vs Heap

```mermaid
graph LR
    A[Dados] --> B[Stack]
    A --> C[Heap]
    
    B --> D[LIFO - Last In, First Out]
    B --> E[Velocidade: R√°pida]
    B --> F[Tamanho: Fixo e Conhecido]
    
    C --> G[Acesso: Ponteiros]
    C --> H[Velocidade: Mais Lento]
    C --> I[Tamanho: Din√¢mico]
    
    style B fill:#e8f5e8
    style C fill:#ffebee
```

**Stack:**
- Estrutura LIFO (Last In, First Out)
- Velocidade: muito r√°pida
- Tamanho: fixo e conhecido em tempo de compila√ß√£o
- Tipos: inteiros, floats, booleans, chars, tuplas, arrays

**Heap:**
- Acesso atrav√©s de ponteiros
- Velocidade: mais lenta que stack
- Tamanho: din√¢mico, pode crescer/diminuir
- Tipos: String, Vec, Box, etc.

### 2.3 Movimento de Ownership

```mermaid
graph TD
    A[let s1 = String::from("hello")] --> B[s1 √© owner do valor]
    B --> C[let s2 = s1]
    C --> D[s1 n√£o √© mais v√°lido]
    D --> E[s2 √© o novo owner]
    E --> F[s2 sai de escopo]
    F --> G[Mem√≥ria liberada automaticamente]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#ffebee
    style E fill:#e8f5e8
    style F fill:#fce4ec
    style G fill:#f1f8e9
```

### 2.4 Refer√™ncias e Borrowing

```mermaid
graph LR
    A[Valor Original] --> B[Refer√™ncia Imut√°vel]
    A --> C[Refer√™ncia Mut√°vel]
    
    B --> D[&T - Read Only]
    C --> E[&mut T - Read/Write]
    
    D --> F[M√∫ltiplas refer√™ncias OK]
    E --> G[Apenas uma refer√™ncia mut√°vel]
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#ffebee
    style D fill:#f3e5f5
    style E fill:#fff3e0
```

**Regras do Borrowing:**

1. **Pode ter m√∫ltiplas refer√™ncias imut√°veis OU uma mut√°vel**
2. **Refer√™ncias devem sempre ser v√°lidas**
3. **N√£o pode misturar refer√™ncias imut√°veis e mut√°veis**

### 2.5 Slices

Slices s√£o refer√™ncias a uma sequ√™ncia cont√≠gua de elementos:

```mermaid
graph TD
    A[Array: [1,2,3,4,5]] --> B[Slice: &[1,2,3]]
    A --> C[String: "Hello World"] --> D[String Slice: &str]
    
    B --> E[Refer√™ncia a parte do array]
    D --> F[Refer√™ncia a parte da string]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#e8f5e8
```

## üíª Exemplos Pr√°ticos

### Exemplo 1: Ownership B√°sico

```rust
// exemplos/ownership_basico.rs
fn main() {
    println!("=== Exemplo: Ownership B√°sico ===");
    
    // Ownership com String (heap)
    let s1 = String::from("hello");
    println!("s1: {}", s1);
    
    // Movimento de ownership
    let s2 = s1; // s1 √© movido para s2
    // println!("s1: {}", s1); // ‚ùå ERRO! s1 n√£o √© mais v√°lido
    println!("s2: {}", s2);
    
    // Clone (c√≥pia profunda)
    let s3 = s2.clone();
    println!("s2: {}", s2); // s2 ainda √© v√°lido
    println!("s3: {}", s3);
    
    // Ownership com tipos primitivos (stack)
    let x = 5;
    let y = x; // C√≥pia autom√°tica (Copy trait)
    println!("x: {}, y: {}", x, y); // Ambos v√°lidos
    
    // Demonstra√ß√£o de escopo
    let s4 = String::from("escopo");
    {
        let s5 = String::from("interno");
        println!("s5: {}", s5);
        // s5 sai de escopo aqui e √© liberado
    }
    println!("s4: {}", s4);
    // s4 sai de escopo aqui e √© liberado
}
```

### Exemplo 2: Fun√ß√µes e Ownership

```rust
// exemplos/funcoes_ownership.rs
fn main() {
    println!("=== Exemplo: Fun√ß√µes e Ownership ===");
    
    let s = String::from("hello");
    
    // Passagem por valor (move)
    toma_ownership(s);
    // println!("s: {}", s); // ‚ùå ERRO! s foi movido
    
    let x = 5;
    
    // Passagem por valor (c√≥pia)
    faz_copia(x);
    println!("x: {}", x); // OK! x ainda √© v√°lido
    
    // Retorno de ownership
    let s1 = String::from("hello");
    let s2 = retorna_ownership(s1);
    println!("s2: {}", s2);
    
    // Fun√ß√£o que recebe e retorna ownership
    let s3 = String::from("hello");
    let s4 = pega_e_retorna_ownership(s3);
    println!("s4: {}", s4);
}

fn toma_ownership(uma_string: String) {
    println!("Recebeu: {}", uma_string);
    // uma_string sai de escopo aqui e √© liberada
}

fn faz_copia(um_inteiro: i32) {
    println!("Recebeu: {}", um_inteiro);
    // um_inteiro sai de escopo aqui, mas √© apenas uma c√≥pia
}

fn retorna_ownership(uma_string: String) -> String {
    println!("Processando: {}", uma_string);
    uma_string // Retorna ownership
}

fn pega_e_retorna_ownership(uma_string: String) -> String {
    uma_string // Recebe e retorna ownership
}
```

### Exemplo 3: Refer√™ncias e Borrowing

```rust
// exemplos/borrowing.rs
fn main() {
    println!("=== Exemplo: Refer√™ncias e Borrowing ===");
    
    let s1 = String::from("hello");
    
    // Empr√©stimo (borrowing) com refer√™ncia imut√°vel
    let tamanho = calcula_tamanho(&s1);
    println!("O tamanho de '{}' √© {}.", s1, tamanho); // s1 ainda √© v√°lido
    
    // Refer√™ncia mut√°vel
    let mut s2 = String::from("hello");
    modifica_string(&mut s2);
    println!("s2 modificado: {}", s2);
    
    // M√∫ltiplas refer√™ncias imut√°veis
    let s3 = String::from("hello world");
    let r1 = &s3;
    let r2 = &s3;
    println!("r1: {}, r2: {}", r1, r2);
    
    // Refer√™ncia mut√°vel (apenas uma por vez)
    let mut s4 = String::from("hello");
    let r3 = &mut s4;
    // let r4 = &mut s4; // ‚ùå ERRO! N√£o pode ter duas refer√™ncias mut√°veis
    println!("r3: {}", r3);
    
    // Refer√™ncia mut√°vel ap√≥s uso
    let mut s5 = String::from("hello");
    let r5 = &s5; // Refer√™ncia imut√°vel
    let r6 = &s5; // Outra refer√™ncia imut√°vel
    println!("r5: {}, r6: {}", r5, r6);
    
    let r7 = &mut s5; // Refer√™ncia mut√°vel ap√≥s uso das imut√°veis
    println!("r7: {}", r7);
}

fn calcula_tamanho(s: &String) -> usize {
    s.len()
    // s sai de escopo aqui, mas n√£o libera a mem√≥ria
    // porque √© apenas uma refer√™ncia
}

fn modifica_string(s: &mut String) {
    s.push_str(", world!");
}
```

### Exemplo 4: Slices

```rust
// exemplos/slices.rs
fn main() {
    println!("=== Exemplo: Slices ===");
    
    // String slice
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
    
    println!("String completa: {}", s);
    println!("Slice 1: {}", hello);
    println!("Slice 2: {}", world);
    
    // Slice com range at√© o final
    let slice_fim = &s[6..];
    println!("Slice at√© o fim: {}", slice_fim);
    
    // Slice do in√≠cio
    let slice_inicio = &s[..5];
    println!("Slice do in√≠cio: {}", slice_inicio);
    
    // Slice completo
    let slice_completo = &s[..];
    println!("Slice completo: {}", slice_completo);
    
    // Array slices
    let array = [1, 2, 3, 4, 5];
    let slice_array = &array[1..4];
    println!("Array: {:?}", array);
    println!("Slice do array: {:?}", slice_array);
    
    // Fun√ß√£o que recebe slice
    let minha_string = String::from("hello world");
    let palavra = primeira_palavra(&minha_string);
    println!("Primeira palavra: {}", palavra);
    
    // Slice como par√¢metro
    let meu_array = [1, 2, 3, 4, 5];
    let soma = somar_slice(&meu_array);
    println!("Soma do array: {}", soma);
}

fn primeira_palavra(s: &str) -> &str {
    let bytes = s.as_bytes();
    
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    
    &s[..]
}

fn somar_slice(slice: &[i32]) -> i32 {
    let mut soma = 0;
    for &item in slice {
        soma += item;
    }
    soma
}
```

## üéØ Tutorial Pr√°tico: Gerenciador de Strings

### Passo 1: Configura√ß√£o do Projeto

```bash
cargo new gerenciador_strings
cd gerenciador_strings
```

### Passo 2: Estrutura do Projeto

```
src/
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ string_manager.rs
‚îî‚îÄ‚îÄ utils.rs
```

### Passo 3: Implementa√ß√£o do Gerenciador

```rust
// src/main.rs
mod string_manager;
mod utils;

use std::io;

fn main() {
    println!("=== Gerenciador de Strings ===");
    
    let mut manager = string_manager::StringManager::new();
    
    loop {
        mostrar_menu();
        
        let escolha = ler_escolha();
        
        match escolha {
            1 => adicionar_string(&mut manager),
            2 => buscar_string(&manager),
            3 => listar_strings(&manager),
            4 => concatenar_strings(&mut manager),
            5 => remover_string(&mut manager),
            6 => {
                println!("Obrigado por usar o gerenciador!");
                break;
            }
            _ => println!("Op√ß√£o inv√°lida!"),
        }
    }
}

fn mostrar_menu() {
    println!("\nEscolha uma opera√ß√£o:");
    println!("1. Adicionar string");
    println!("2. Buscar string");
    println!("3. Listar todas as strings");
    println!("4. Concatenar strings");
    println!("5. Remover string");
    println!("6. Sair");
    print!("Digite sua escolha (1-6): ");
}

fn ler_escolha() -> u32 {
    let mut entrada = String::new();
    io::stdin()
        .read_line(&mut entrada)
        .expect("Falha ao ler entrada");
    
    entrada.trim().parse().unwrap_or(0)
}

fn adicionar_string(manager: &mut string_manager::StringManager) {
    println!("Digite a string para adicionar:");
    let mut entrada = String::new();
    io::stdin()
        .read_line(&mut entrada)
        .expect("Falha ao ler entrada");
    
    let string = entrada.trim().to_string();
    manager.adicionar(string);
    println!("String adicionada com sucesso!");
}

fn buscar_string(manager: &string_manager::StringManager) {
    println!("Digite a string para buscar:");
    let mut entrada = String::new();
    io::stdin()
        .read_line(&mut entrada)
        .expect("Falha ao ler entrada");
    
    let busca = entrada.trim();
    if manager.buscar(busca) {
        println!("String encontrada!");
    } else {
        println!("String n√£o encontrada!");
    }
}

fn listar_strings(manager: &string_manager::StringManager) {
    println!("Strings armazenadas:");
    for (i, string) in manager.listar().iter().enumerate() {
        println!("{}. {}", i + 1, string);
    }
}

fn concatenar_strings(manager: &mut string_manager::StringManager) {
    println!("Digite o √≠ndice da primeira string:");
    let idx1 = ler_indice();
    
    println!("Digite o √≠ndice da segunda string:");
    let idx2 = ler_indice();
    
    if let Some(resultado) = manager.concatenar(idx1, idx2) {
        println!("Resultado da concatena√ß√£o: {}", resultado);
    } else {
        println!("√çndices inv√°lidos!");
    }
}

fn remover_string(manager: &mut string_manager::StringManager) {
    println!("Digite o √≠ndice da string para remover:");
    let idx = ler_indice();
    
    if manager.remover(idx) {
        println!("String removida com sucesso!");
    } else {
        println!("√çndice inv√°lido!");
    }
}

fn ler_indice() -> usize {
    let mut entrada = String::new();
    io::stdin()
        .read_line(&mut entrada)
        .expect("Falha ao ler entrada");
    
    entrada.trim().parse().unwrap_or(0)
}
```

```rust
// src/string_manager.rs
use crate::utils;

pub struct StringManager {
    strings: Vec<String>,
}

impl StringManager {
    pub fn new() -> Self {
        StringManager {
            strings: Vec::new(),
        }
    }
    
    pub fn adicionar(&mut self, string: String) {
        self.strings.push(string);
    }
    
    pub fn buscar(&self, busca: &str) -> bool {
        self.strings.iter().any(|s| s.contains(busca))
    }
    
    pub fn listar(&self) -> &Vec<String> {
        &self.strings
    }
    
    pub fn concatenar(&mut self, idx1: usize, idx2: usize) -> Option<String> {
        if idx1 < self.strings.len() && idx2 < self.strings.len() {
            let s1 = &self.strings[idx1];
            let s2 = &self.strings[idx2];
            Some(format!("{}{}", s1, s2))
        } else {
            None
        }
    }
    
    pub fn remover(&mut self, idx: usize) -> bool {
        if idx < self.strings.len() {
            self.strings.remove(idx);
            true
        } else {
            false
        }
    }
    
    pub fn tamanho(&self) -> usize {
        self.strings.len()
    }
    
    pub fn estatisticas(&self) -> (usize, usize, usize) {
        let total_strings = self.strings.len();
        let total_chars: usize = self.strings.iter().map(|s| s.len()).sum();
        let strings_vazias = self.strings.iter().filter(|s| s.is_empty()).count();
        
        (total_strings, total_chars, strings_vazias)
    }
}
```

```rust
// src/utils.rs
pub fn formatar_string(s: &str) -> String {
    s.trim().to_lowercase()
}

pub fn validar_string(s: &str) -> bool {
    !s.trim().is_empty() && s.len() <= 100
}

pub fn contar_palavras(s: &str) -> usize {
    s.split_whitespace().count()
}

pub fn inverter_string(s: &str) -> String {
    s.chars().rev().collect()
}

pub fn remover_duplicatas(strings: &[String]) -> Vec<String> {
    let mut unicas = Vec::new();
    for string in strings {
        if !unicas.contains(string) {
            unicas.push(string.clone());
        }
    }
    unicas
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_formatar_string() {
        assert_eq!(formatar_string("  HELLO WORLD  "), "hello world");
    }

    #[test]
    fn test_validar_string() {
        assert!(validar_string("hello"));
        assert!(!validar_string(""));
        assert!(!validar_string("   "));
    }

    #[test]
    fn test_contar_palavras() {
        assert_eq!(contar_palavras("hello world"), 2);
        assert_eq!(contar_palavras(""), 0);
    }

    #[test]
    fn test_inverter_string() {
        assert_eq!(inverter_string("hello"), "olleh");
    }
}
```

## üéØ Atividades Pr√°ticas

### Atividade 1: Sistema de Cache

Implemente um sistema de cache que gerencie ownership de dados:

**Requisitos:**
- Armazenar chave-valor
- LRU (Least Recently Used)
- Gerenciamento de mem√≥ria eficiente
- API thread-safe

### Atividade 2: Processador de Texto

Crie um processador de texto que trabalhe com slices:

**Funcionalidades:**
- Busca e substitui√ß√£o
- Formata√ß√£o de texto
- Estat√≠sticas de palavras
- Exporta√ß√£o de dados

### Atividade 3: Gerenciador de Arquivos

Desenvolva um gerenciador de arquivos em mem√≥ria:

**Caracter√≠sticas:**
- Hierarquia de diret√≥rios
- Opera√ß√µes CRUD
- Navega√ß√£o por refer√™ncias
- Backup e restore

## üìù Exerc√≠cios de Fixa√ß√£o

1. **Pergunta:** O que acontece quando voc√™ move uma String para outra vari√°vel?
   - Resposta: O ownership √© transferido e a vari√°vel original n√£o √© mais v√°lida

2. **Pergunta:** Qual a diferen√ßa entre `&T` e `&mut T`?
   - Resposta: `&T` √© refer√™ncia imut√°vel (read-only), `&mut T` √© refer√™ncia mut√°vel (read/write)

3. **Pergunta:** Por que Rust n√£o precisa de garbage collector?
   - Resposta: Porque o sistema de ownership libera automaticamente a mem√≥ria quando o owner sai de escopo

4. **Pergunta:** O que √© um slice em Rust?
   - Resposta: Uma refer√™ncia a uma sequ√™ncia cont√≠gua de elementos em uma cole√ß√£o

## üîó Pr√≥ximos Passos

No pr√≥ximo m√≥dulo, voc√™ aprender√° a:

- Definir e usar structs
- Trabalhar com enums e suas variantes
- Aplicar pattern matching com match
- Criar tipos de dados customizados

## üß≠ **Navega√ß√£o**

### **üìö Material de Apoio**
- [**README Principal**](../../README.md) - Vis√£o geral do curso
- [**Tutoriais Detalhados**](../../TUTORIAIS.md) - Guia completo de tutoriais
- [**M√≥dulo 1: Fundamentos**](../modulo-01-fundamentos-rust/README.md) - M√≥dulo anterior
- [**M√≥dulo 3: Structs/Enums**](../modulo-03-structs-enums/README.md) - Pr√≥ximo m√≥dulo
- [**M√≥dulo Embarcados**](../modulo-embarcados/README.md) - Desenvolvimento IoT

### **üîó Links √öteis**
- [Comunidade Rust Brasil](https://github.com/rust-br)
- [Documenta√ß√£o Oficial](https://doc.rust-lang.org/)
- [Rust Playground](https://play.rust-lang.org/)
- [Crates.io](https://crates.io/)

### **üìñ Documenta√ß√£o Oficial**
- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- [Rustlings](https://github.com/rust-lang/rustlings)
- [Cargo Book](https://doc.rust-lang.org/cargo/)

---

**Professor:** Jackson S√°  
**ETEC Bento Quirino - Campinas/SP**
